#include <iostream>
using namespace std;

// ---------------------------------------------------------
// Binary_tree class (lab manual style)
// ---------------------------------------------------------
template <typename Type>
class Binary_tree {
private:
    Type element;
    Binary_tree<Type>* parent_node;
    Binary_tree<Type>* left_child;
    Binary_tree<Type>* right_child;

public:
    // Constructor
    Binary_tree(Type const& = Type(), Binary_tree<Type>* = NULL);

    // Accessors
    Type retrieve() const;
    Binary_tree<Type>* parent() const;
    Binary_tree<Type>* left() const;
    Binary_tree<Type>* right() const;

    // Status checks
    bool is_root() const;
    bool is_leaf() const;

    // Mutators
    void insert_left(Type const&);
    void insert_right(Type const&);

    // Traversals
    void depth_first_traversal() const;
    void breadth_first_traversal() const;
};

// ---------------------------------------------------------
// Constructor
// ---------------------------------------------------------
template <typename Type>
Binary_tree<Type>::Binary_tree(Type const& obj, Binary_tree<Type>* p)
    : element(obj),
      parent_node(p),
      left_child(NULL),
      right_child(NULL) {}

// ---------------------------------------------------------
// Accessors
// ---------------------------------------------------------
template <typename Type>
Type Binary_tree<Type>::retrieve() const {
    return element;
}

template <typename Type>
Binary_tree<Type>* Binary_tree<Type>::parent() const {
    return parent_node;
}

template <typename Type>
Binary_tree<Type>* Binary_tree<Type>::left() const {
    return left_child;
}

template <typename Type>
Binary_tree<Type>* Binary_tree<Type>::right() const {
    return right_child;
}

// ---------------------------------------------------------
// Status checks
// ---------------------------------------------------------
template <typename Type>
bool Binary_tree<Type>::is_root() const {
    return parent_node == NULL;
}

template <typename Type>
bool Binary_tree<Type>::is_leaf() const {
    return (left_child == NULL && right_child == NULL);
}

// ---------------------------------------------------------
// Insert functions
// ---------------------------------------------------------
template <typename Type>
void Binary_tree<Type>::insert_left(Type const& obj) {
    left_child = new Binary_tree<Type>(obj, this);
}

template <typename Type>
void Binary_tree<Type>::insert_right(Type const& obj) {
    right_child = new Binary_tree<Type>(obj, this);
}

// ---------------------------------------------------------
// Depth First Traversal (Preorder)
// ---------------------------------------------------------
template <typename Type>
void Binary_tree<Type>::depth_first_traversal() const {
    cout << element << "\t";

    if (left_child != NULL) {
        left_child->depth_first_traversal();
    }

    if (right_child != NULL) {
        right_child->depth_first_traversal();
    }
}

// ---------------------------------------------------------
// Breadth First Traversal (Level Order)
// ---------------------------------------------------------
template <typename Type>
void Binary_tree<Type>::breadth_first_traversal() const {
    Binary_tree<Type>* queue[50];
    int front = 0;
    int rear = 0;

    queue[rear++] = const_cast<Binary_tree<Type>*>(this);

    while (front < rear) {
        Binary_tree<Type>* current = queue[front++];
        cout << current->retrieve() << "\t";

        if (current->left_child != NULL) {
            queue[rear++] = current->left_child;
        }

        if (current->right_child != NULL) {
            queue[rear++] = current->right_child;
        }
    }
}

// ---------------------------------------------------------
// Main function (testing)
// ---------------------------------------------------------
int main() {

    Binary_tree<char>* root = new Binary_tree<char>('A');

    root->insert_left('B');
    root->insert_right('C');

    root->left()->insert_left('D');
    root->right()->insert_right('E');

    cout << "Depth First Traversal:\n";
    root->depth_first_traversal();

    cout << "\n\nBreadth First Traversal:\n";
    root->breadth_first_traversal();

    return 0;
}
