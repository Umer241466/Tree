//Node class
template <typename Type>
class Node {
private:
    Type element;
    Node<Type>* next_node;

public:
    Node(Type const& e, Node<Type>* n = nullptr) :
        element(e), next_node(n) {}

    Type retrieve() const { return element; }
    Node<Type>* next() const { return next_node; }
    void set_next(Node<Type>* n) { next_node = n; }
};

// LLclass
template <typename Type>
class linkedlist {
private:
    Node<Type>* head_node;
    Node<Type>* tail_node;
    int list_size;

public:
    linkedlist() : head_node(nullptr), tail_node(nullptr), list_size(0) {}

    Node<Type>* head() const { return head_node; }
    int size() const { return list_size; }

    void push_back(Type const& obj) {
        Node<Type>* n = new Node<Type>(obj);
        if (!head_node) {
            head_node = tail_node = n;
        } else {
            tail_node->set_next(n);
            tail_node = n;
        }
        list_size++;
    }

    // erase a specific pointer (PPT-style detach)
    void erase(Type obj) {
        if (!head_node) return;

        if (head_node->retrieve() == obj) {
            Node<Type>* temp = head_node;
            head_node = head_node->next();
            delete temp;
            list_size--;
            return;
        }

        Node<Type>* prev = head_node;
        Node<Type>* curr = head_node->next();

        while (curr != nullptr) {
            if (curr->retrieve() == obj) {
                prev->set_next(curr->next());
                delete curr;
                list_size--;
                return;
            }
            prev = curr;
            curr = curr->next();
        }
    }
};

//QUE CLASS
template <typename Type>
class Queue {
private:
    linkedlist<Type> list;

public:
    void push(Type const& obj) { list.push_back(obj); }
    bool empty() const { return list.size() == 0; }

    Type pop() {
        Node<Type>* h = list.head();
        Type value = h->retrieve();
        list.erase(value);
        return value;
    }
};

//simple tree class
template <typename Type>
class Simple_tree {
private:
    Type node_value;
    Simple_tree* parent_node;
    linkedlist<Simple_tree*> children;

public:
    Simple_tree(Type const& = Type(), Simple_tree* = nullptr);

    Type retrieve() const;
    Simple_tree* parent() const;
    Simple_tree* child(int n) const;
    int degree() const;
    bool is_root() const;
    bool is_leaf() const;

    int size() const;
    int height() const;

    void insert(Type const&);
    void attach(Simple_tree*);
    void detach();

    void depth_first_traversal() const;
    void breadth_first_traversal();
};
//implementation
template <typename Type>
Simple_tree<Type>::Simple_tree(Type const& obj, Simple_tree* p)
    : node_value(obj), parent_node(p) {}

template <typename Type>
Type Simple_tree<Type>::retrieve() const {
    return node_value;
}

template <typename Type>
Simple_tree<Type>* Simple_tree<Type>::parent() const {
    return parent_node;
}

template <typename Type>
Simple_tree<Type>* Simple_tree<Type>::child(int n) const {
    if (n < 0 || n >= degree()) return nullptr;

    Node<Simple_tree*>* ptr = children.head();
    for (int i = 0; i < n; i++)
        ptr = ptr->next();

    return ptr->retrieve();
}

template <typename Type>
int Simple_tree<Type>::degree() const {
    return children.size();
}

template <typename Type>
bool Simple_tree<Type>::is_root() const {
    return parent_node == nullptr;
}

template <typename Type>
bool Simple_tree<Type>::is_leaf() const {
    return degree() == 0;
}

template <typename Type>
void Simple_tree<Type>::insert(Type const& obj) {
    children.push_back(new Simple_tree(obj, this));
}

template <typename Type>
int Simple_tree<Type>::size() const {
    int s = 1;
    for (Node<Simple_tree*>* ptr = children.head(); ptr != nullptr; ptr = ptr->next())
        s += ptr->retrieve()->size();
    return s;
}

template <typename Type>
int Simple_tree<Type>::height() const {
    int h = 0;
    for (Node<Simple_tree*>* ptr = children.head(); ptr != nullptr; ptr = ptr->next())
        h = std::max(h, 1 + ptr->retrieve()->height());
    return h;
}

template <typename Type>
void Simple_tree<Type>::attach(Simple_tree<Type>* tree) {
    if (!tree->is_root()) tree->detach();
    tree->parent_node = this;
    children.push_back(tree);
}

template <typename Type>
void Simple_tree<Type>::detach() {
    if (is_root()) return;
    parent()->children.erase(this);
    parent_node = nullptr;
}

template <typename Type>
void Simple_tree<Type>::depth_first_traversal() const {
    cout << retrieve() << "\t";
    for (Node<Simple_tree*>* ptr = children.head(); ptr != nullptr; ptr = ptr->next())
        ptr->retrieve()->depth_first_traversal();
}

template <typename Type>
void Simple_tree<Type>::breadth_first_traversal() {
    Queue<Simple_tree*> q;
    q.push(this);

    while (!q.empty()) {
        Simple_tree* p = q.pop();
        cout << p->retrieve() << "\t";
int main() {
    Tree<int> myTree(1); // Root node = 1

    TreeNode<int>* root = myTree.getRoot();
    root->addChild(2);
    root->addChild(3);
    root->addChild(4);

    TreeNode<int>* node2 = myTree.find(2);
    if (node2) {
        node2->addChild(5);
        node2->addChild(6);
    }

    TreeNode<int>* node3 = myTree.find(3);
    if (node3) {
        node3->addChild(7);
    }

    std::cout << "Preorder traversal: ";
    myTree.preorder(root);
    std::cout << "\nPostorder traversal: ";
    myTree.postorder(root);
    std::cout << "\nLevel-order traversal: ";
    myTree.levelOrder();
    std::cout << std::endl;

    return 0;
}
        for (Node<Simple_tree*>* ptr = p->children.head(); ptr != nullptr; ptr = ptr->next())
            q.push(ptr->retrieve());
    }
}
