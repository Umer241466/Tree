#include <iostream>
using namespace std;

template <typename Type>
class Perfect_tree {
private:
    Type element;
    Perfect_tree* parent_node;
    Perfect_tree* left_child;
    Perfect_tree* right_child;

public:
    Perfect_tree(Type const& = Type(), Perfect_tree* = NULL);

    Type retrieve() const;
    Perfect_tree* parent() const;
    Perfect_tree* left() const;
    Perfect_tree* right() const;

    bool is_root() const;
    bool is_leaf() const;

    void insert_left(Type const&);
    void insert_right(Type const&);

    void depth_first_traversal() const;
    void breadth_first_traversal();
};

template <typename Type>
Perfect_tree<Type>::Perfect_tree(Type const& obj, Perfect_tree* p)
    : element(obj), parent_node(p),
      left_child(NULL), right_child(NULL) {}

template <typename Type>
Type Perfect_tree<Type>::retrieve() const {
    return element;
}

template <typename Type>
Perfect_tree<Type>* Perfect_tree<Type>::parent() const {
    return parent_node;
}

template <typename Type>
Perfect_tree<Type>* Perfect_tree<Type>::left() const {
    return left_child;
}

template <typename Type>
Perfect_tree<Type>* Perfect_tree<Type>::right() const {
    return right_child;
}

template <typename Type>
bool Perfect_tree<Type>::is_root() const {
    return parent_node == NULL;
}

template <typename Type>
bool Perfect_tree<Type>::is_leaf() const {
    return (left_child == NULL && right_child == NULL);
}

template <typename Type>
void Perfect_tree<Type>::insert_left(Type const& obj) {
    left_child = new Perfect_tree(obj, this);
}

template <typename Type>
void Perfect_tree<Type>::insert_right(Type const& obj) {
    right_child = new Perfect_tree(obj, this);
}

template <typename Type>
void Perfect_tree<Type>::depth_first_traversal() const {
    cout << element << "\t";
    if (left_child)
        left_child->depth_first_traversal();
    if (right_child)
        right_child->depth_first_traversal();
}

template <typename Type>
void Perfect_tree<Type>::breadth_first_traversal() {
    Perfect_tree* queue[50];
    int front = 0, rear = 0;

    queue[rear++] = this;

    while (front < rear) {
        Perfect_tree* p = queue[front++];
        cout << p->retrieve() << "\t";

        if (p->left_child)
            queue[rear++] = p->left_child;
        if (p->right_child)
            queue[rear++] = p->right_child;
    }
}

int main() {

    Perfect_tree<char>* root = new Perfect_tree<char>('U');

    root->insert_left('M');
    root->insert_right('E');

    root->left()->insert_left('X');
    root->left()->insert_right('Y');

    root->right()->insert_left('R');
    root->right()->insert_right('S');

    root->depth_first_traversal();
    cout << endl;
    root->breadth_first_traversal();

    return 0;
}
